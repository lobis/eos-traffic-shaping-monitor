// ----------------------------------------------------------------------------
// File: TrafficShaping.proto
// Author: Luis Antonio Obis Aparicio <luis.obis@cern.ch>
// ----------------------------------------------------------------------------

syntax = "proto3";

package eos.traffic_shaping;

option go_package = "eos_traffic_shaping_monitor/proto";

// Represents the I/O stats for a single "Stream" (Unique App/UID/GID combo).
// This is only sent if the counters have changed since the last report.
message IoStatEntry {
  // --- Identity ---
  // The application name (e.g., "backup_daemon", "chrome").
  // TODO: Consider mapping this to an int32 ID in a separate dictionary if string overhead is too high.
  string app_name = 1;
  uint32 uid = 2; // The user ID
  uint32 gid = 3; // The group ID

  // --- Lifecycle Safety ---
  // A unique random ID generated when this counter was created in the Node's memory.
  // CRITICAL: If the Node garbage collects this entry and recreates it later (starting from 0),
  // this ID MUST change. This tells the Brain "This is a new session, do not diff against old value."
  uint64 generation_id = 4;

  // --- Metrics (Cumulative) ---
  // We use cumulative counters to be robust against packet loss.
  // The Brain calculates: Delta = Current - Previous.
  uint64 total_bytes_read = 5;
  uint64 total_bytes_written = 6;
  // IOPS
  uint64 total_read_ops = 7;
  uint64 total_write_ops = 8;
}

// The heartbeat message sent every 1 second by every Storage Node.
message FstIoReport {
  // --- Metadata ---
  string node_id = 1;             // Unique Hostname or UUID of the FST
  int64 timestamp_ms = 2;         // When this snapshot was taken (Unix Epoch)

  // To detect Node Restarts. If this changes, MGM discards all previous state for this Node.
  int64 node_start_time_ms = 3;

  // --- Payload ---
  // List of streams that have activity. Idle streams are omitted to save bandwidth.
  repeated IoStatEntry entries = 4;
}

message MgmIoResponse {
  // We will fill this with rate-limit instructions later.
  // For now, it can just acknowledge receipt.
  bool ack = 1;
}

service TrafficShapingService {
  // Bidirectional streaming: The FST opens a stream and pushes FstIoReport repeatedly.
  // The MGM can push back MgmIoResponse (limits/acks) asynchronously.
  rpc StreamIoStats(stream FstIoReport) returns (stream MgmIoResponse);
}

// service in the mgm which will report rates / iops for a given app, uid or gid

// --- Core Data Structures ---

message RateStats {
  RateRequest.Estimators window = 1;

  double bytes_read_per_sec = 2;
  double bytes_written_per_sec = 3;
  double iops_read = 4;
  double iops_write = 5;
}

message AppRateEntry {
  string app_name = 1;
  // CHANGE THIS: Add 'repeated'
  repeated RateStats stats = 2;
}

message UserRateEntry {
  uint32 uid = 1;
  // CHANGE THIS: Add 'repeated'
  repeated RateStats stats = 2;
}

message GroupRateEntry {
  uint32 gid = 1;
  // CHANGE THIS: Add 'repeated'
  repeated RateStats stats = 2;
}

// --- Request Definition ---

message RateRequest {
  enum Estimators {
    UNSPECIFIED = 0; // Proto3 best practice (default 0 should be no-op)
    // SMA
    SMA_5_SECONDS = 1;
    SMA_1_MINUTES = 2;
    SMA_5_MINUTES = 3;
    // EMA
    EMA_5_SECONDS = 4;
    EMA_1_MINUTES = 5;
    EMA_5_MINUTES = 6;
  }
  repeated Estimators estimators = 1;

  enum EntityType {
    ENTITY_UNSPECIFIED = 0;
    ENTITY_APP = 1;
    ENTITY_UID = 2;
    ENTITY_GID = 3;
  }
  repeated EntityType include_types = 2;

  // How many top entries to return for each type? (e.g., Top 10 apps)
  optional uint32 top_n = 3;

  // --- 4. Sorting Ambiguity Resolver ---
  // If I ask for 5s and 5m windows, which one determines who is in the "Top 10"?
  // (e.g., Sort by 5m trend, but show me the 1s spikes too)
  optional Estimators sort_by_estimator = 4;
}

// --- Response Definition ---

message RateReport {
  int64 timestamp_ms = 1;

  // These are only filled if requested in RateRequest
  repeated AppRateEntry app_stats = 2;
  repeated UserRateEntry user_stats = 3;
  repeated GroupRateEntry group_stats = 4;
}

service RateReportingService {
  // Unary: Get a single snapshot (e.g., for a CLI tool like 'eos io stat')
  rpc GetRates(RateRequest) returns (RateReport);

  // Streaming: Get live updates (e.g., for a Web Dashboard / Grafana)
  rpc StreamRates(RateRequest) returns (stream RateReport);
}
